

<@include display-plugins/VisionSqueeze.slh@>

struct PresentWithVisionSqueezeParams {
    float _visionSqueezeX;
    float _visionSqueezeY;
    float _ipd;
    float _spareB;
    mat4 _leftProjection;
    mat4 _rightProjection;
    mat4 _hmdSensorMatrix;
    float _visionSqueezeTransition;
    int _visionSqueezePerEye;
    float _visionSqueezeGroundPlaneY;
    float _visionSqueezeSpotlightSize;
};

LAYOUT(binding=0) uniform sampler2D colorMap;

// binding=1 must match presentWithVisionSqueezeParamsSlot in OpenGLDisplayPlugin.h
LAYOUT(binding=1) uniform presentWithSqueezeMappingParamsBuffer {
    PresentWithVisionSqueezeParams params;
};

layout(location=0) in vec2 varTexCoord0;

layout(location=0) out vec4 outFragColor;

float sRGBFloatToLinear(float value) {
    const float SRGB_ELBOW = 0.04045;

    return mix(pow((value + 0.055) / 1.055, 2.4), value / 12.92, float(value <= SRGB_ELBOW));
}

vec3 colorToLinearRGB(vec3 srgb) {
    return vec3(sRGBFloatToLinear(srgb.r), sRGBFloatToLinear(srgb.g), sRGBFloatToLinear(srgb.b));
}

float getVisionSqueezeX() {
    return params._visionSqueezeX;
}
float getVisionSqueezeY() {
    return params._visionSqueezeY;
}
float getIPD() {
    return params._ipd;
}
float getVisionSqueezeTransitionRatio() {
    return params._visionSqueezeTransition;
}
int getVisionSqueezePerEye() {
    return params._visionSqueezePerEye;
}
float getVisionSqueezeGroundPlaneY() {
    return params._visionSqueezeGroundPlaneY;
}
float getVisionSqueezeSpotlightSize() {
    return params._visionSqueezeSpotlightSize;
}
mat4 getProjectionMatrix(int eye) {
    if (eye == 0) {
        return params._leftProjection;
    } else {
        return params._rightProjection;
    }
}
mat4 getHMDSensorMatrix() {
    return params._hmdSensorMatrix;
}


void main(void) {

    outFragColor.a = 1.0;
    vec3 linearColor = colorToLinearRGB(texture(colorMap, varTexCoord0).rgb);

    // block edges of vision to avoid sickness
    vec2 visionSqueezeRatios = vec2(getVisionSqueezeX(), getVisionSqueezeY());
    bool perEye = getVisionSqueezePerEye() > 0;
    float frac = squeezeVision(perEye, varTexCoord0, visionSqueezeRatios, getVisionSqueezeTransitionRatio());

    // put a grid on the floor
    int side = int(varTexCoord0.x > 0.5);
    mat4 hmdSensorMatrix = getHMDSensorMatrix();
    mat4 projectionMatrix = getProjectionMatrix(side);
    mat4 projectionInverse = inverse(projectionMatrix);
    float groundPlaneY = getVisionSqueezeGroundPlaneY();
    float spotLightSize = getVisionSqueezeSpotlightSize();
    vec3 gridColor = gridFloor(varTexCoord0, hmdSensorMatrix, projectionInverse, groundPlaneY, spotLightSize);

    outFragColor.rgb = mix(linearColor, gridColor, frac);
}
