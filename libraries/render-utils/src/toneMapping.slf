<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on Sat Oct 24 09:34:37 2015
//
//  toneMapping.frag
//
//  Draw texture 0 fetched at texcoord.xy
//
//  Created by Sam Gateau on 6/22/2015
//  Copyright 2015 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include render-utils/ShaderConstants.h@>
<@include gpu/Transform.slh@>
<@include DeferredTransform.slh@>
<$declareStandardCameraTransform()$>

<@include gpu/ShaderConstants.h@>
<@include gpu/Paint.slh@>

struct ToneMappingParams {
    vec4 _exp_2powExp_s0_s1;
    ivec4 _toneCurve_s0_s1_s2;
    mat4 _sensorToCameraTransform;
};

const float INV_GAMMA_22 = 1.0 / 2.2;
const int ToneCurveNone = 0;
const int ToneCurveGamma22 = 1;
const int ToneCurveReinhard = 2;
const int ToneCurveFilmic = 3;

LAYOUT(binding=RENDER_UTILS_BUFFER_TM_PARAMS) uniform toneMappingParamsBuffer {
    ToneMappingParams params;
};
float getTwoPowExposure() {
    return params._exp_2powExp_s0_s1.y;
}
int getToneCurve() {
    return params._toneCurve_s0_s1_s2.x;
}
float getVisionSqueeze() {
    return params._exp_2powExp_s0_s1.z;
}
mat4 getHMDSensorMatrix() {
    return params._sensorToCameraTransform;
}

float checkerboard(vec2 R, float scale) {
	return float((int(floor(R.x / scale)) + int(floor(R.y / scale))) % 2);
}


LAYOUT(binding=RENDER_UTILS_TEXTURE_TM_COLOR) uniform sampler2D colorMap;

layout(location=0) in vec2 varTexCoord0;
layout(location=0) out vec4 outFragColor;

void main(void) {
    vec4 fragColorRaw = texture(colorMap, varTexCoord0);
    vec3 fragColor = fragColorRaw.xyz;

    vec3 srcColor = fragColor * getTwoPowExposure();

    int toneCurve = getToneCurve();
    vec3 tonedColor = srcColor;
    if (toneCurve == ToneCurveFilmic) {
        vec3 x = max(vec3(0.0), srcColor-0.004);
        tonedColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
    } else if (toneCurve == ToneCurveReinhard) {
        tonedColor = srcColor/(1.0 + srcColor);
        tonedColor = pow(tonedColor, vec3(INV_GAMMA_22));
    } else if (toneCurve == ToneCurveGamma22) {
        tonedColor = pow(srcColor, vec3(INV_GAMMA_22));
    } // else None toned = src

    // darken the edges of the view to avoid sickness
    float visionSqueeze = getVisionSqueeze(); // 0 = nothing darkened.  1 = all darkened
    float dst = distance(varTexCoord0, vec2(0.5, 0.5)) * 2.0; // fragment distance from screen center
    float transitionRatio = 0.15; // how quickly to switch from unobstructed to black
    float lightEdge = sqrt(2.0) * (1.0 - visionSqueeze); // sqrt(2) for corner of screen
    float darkEdge = lightEdge + transitionRatio;
    float frac = clamp((dst - lightEdge) / (darkEdge - lightEdge), 0.0, 1.0);

    // put a grid on the floor
    float halfIPD = 0.3; // XXX I have no idea where to get this number
    if (varTexCoord0.x < 0.5) {
        halfIPD = -halfIPD;
    }
    TransformCamera cam = getTransformCamera();
    mat4 hmdSensorMatrix = getHMDSensorMatrix();
    vec4 ndc;
    if (varTexCoord0.x < 0.5) {
        ndc = vec4(varTexCoord0.x * 4.0 - 1.0, varTexCoord0.y * 2.0 - 1.0, -1.0, 1.0);
    } else {
        ndc = vec4(varTexCoord0.x * 4.0 - 3.0, varTexCoord0.y * 2.0 - 1.0, -1.0, 1.0);
    }
    vec4 fragmentEyeCoords = hmdSensorMatrix * (cam._projectionInverse * ndc + vec4(halfIPD, 0.0, 0.0, 0.0));
    vec4 near4 = hmdSensorMatrix * vec4(halfIPD / 2.0, 0.0, 0.0, 1.0);
    vec3 near = (near4 / near4.w).xyz;
    vec3 far = fragmentEyeCoords.xyz / fragmentEyeCoords.w;

    // intersect a line from near to far with the plane y = 0
    float t = -near.y / (far.y - near.y);
    vec3 R = near + t * (far - near);
    // use (x, z) from that intersection to determine grid color for this fragment
    float c =
        checkerboard(R.xz, 1) * 0.3 +
        checkerboard(R.xz, 10) * 0.2 +
        checkerboard(R.xz, 100) * 0.1 +
        0.1;
    c = c * float(t > 0);
    float spotlight = min(1.0, 1.5 - 0.02 * length(R.xz));
    vec3 gridColor = vec3(c * spotlight);

    tonedColor = mix(tonedColor, gridColor, frac);
    outFragColor = vec4(tonedColor, 1.0);
}
