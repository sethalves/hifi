<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on Sat Oct 24 09:34:37 2015
//
//  toneMapping.frag
//
//  Draw texture 0 fetched at texcoord.xy
//
//  Created by Sam Gateau on 6/22/2015
//  Copyright 2015 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include render-utils/ShaderConstants.h@>
<@include gpu/Transform.slh@>
<@include DeferredTransform.slh@>
<$declareStandardCameraTransform()$>

<@include gpu/ShaderConstants.h@>
<@include gpu/Paint.slh@>

struct ToneMappingParams {
    vec4 _exp_2powExp_s0_s1;
    ivec4 _toneCurve_s0_s1_s2;
    mat4 _sensorToCameraTransform;

    // TODO -- remove these after tuning / debugging
    float _visionSqueezeTransition;
    int _visionSqueezePerEye;
    // float _visionSqueezeSensorSpaceEyeOffset;
    mat4 _leftEyeOffset;
    mat4 _rightEyeOffset;
    float _visionSqueezeGroundPlaneY;
    float _visionSqueezeSpotlightSize;
};

const float INV_GAMMA_22 = 1.0 / 2.2;
const int ToneCurveNone = 0;
const int ToneCurveGamma22 = 1;
const int ToneCurveReinhard = 2;
const int ToneCurveFilmic = 3;

LAYOUT(binding=RENDER_UTILS_BUFFER_TM_PARAMS) uniform toneMappingParamsBuffer {
    ToneMappingParams params;
};
float getTwoPowExposure() {
    return params._exp_2powExp_s0_s1.y;
}
int getToneCurve() {
    return params._toneCurve_s0_s1_s2.x;
}
float getVisionSqueeze() {
    return params._exp_2powExp_s0_s1.z;
}
mat4 getHMDSensorMatrix() {
    return params._sensorToCameraTransform;
}
float getVisionSqueezeTransitionRatio() {
    return params._visionSqueezeTransition;
}
int getVisionSqueezePerEye() {
    return params._visionSqueezePerEye;
}
mat4 getVisionSqueezeSensorSpaceEyeOffset(int eye) {
    if (eye == 0) {
        return params._leftEyeOffset;
    } else {
        return params._rightEyeOffset;
    }
}
float getVisionSqueezeGroundPlaneY() {
    return params._visionSqueezeGroundPlaneY;
}
float getVisionSqueezeSpotlightSize() {
    return params._visionSqueezeSpotlightSize;
}

float checkerboard(vec2 R, float scale) {
	return float((int(floor(R.x / scale)) + int(floor(R.y / scale))) % 2);
}

// float sigmoid(float v) {
//     return v / (1.0 + abs(v));
// }

// float sigmoid(float v) {
//     return 1.0 / (1.0 + exp(-2.0 * v));
// }

// float sigmoid(float v) {
//     if (v < 0.5) return 0;
//     return 1;
// }

float sigmoid(float v) {
    return v;
}


LAYOUT(binding=RENDER_UTILS_TEXTURE_TM_COLOR) uniform sampler2D colorMap;

layout(location=0) in vec2 varTexCoord0;
layout(location=0) out vec4 outFragColor;

void main(void) {
    vec4 fragColorRaw = texture(colorMap, varTexCoord0);
    vec3 fragColor = fragColorRaw.xyz;

    vec3 srcColor = fragColor * getTwoPowExposure();

    int toneCurve = getToneCurve();
    vec3 tonedColor = srcColor;
    if (toneCurve == ToneCurveFilmic) {
        vec3 x = max(vec3(0.0), srcColor-0.004);
        tonedColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
    } else if (toneCurve == ToneCurveReinhard) {
        tonedColor = srcColor/(1.0 + srcColor);
        tonedColor = pow(tonedColor, vec3(INV_GAMMA_22));
    } else if (toneCurve == ToneCurveGamma22) {
        tonedColor = pow(srcColor, vec3(INV_GAMMA_22));
    } // else None toned = src

    // darken the edges of the view to avoid sickness
    float visionSqueeze = getVisionSqueeze(); // 0 = nothing darkened.  1 = all darkened

    float dst;
    if (getVisionSqueezePerEye() > 0) {
        // tubes in front of each eye
        dst = min(distance(varTexCoord0, vec2(0.25, 0.5)),
                  distance(varTexCoord0, vec2(0.75, 0.5)));
    } else {
        // one tube in front of face
        dst = distance(varTexCoord0, vec2(0.5, 0.5)); // fragment distance from screen center
    }

    float transitionRatio = getVisionSqueezeTransitionRatio();

    float lightEdge = sqrt(0.5*0.5 + 0.5*0.5) * (1.0 - visionSqueeze); // screencorner * (1.0 - visionSqueeze)
    float darkEdge = lightEdge + transitionRatio;
    float frac = clamp(sigmoid((dst - lightEdge) / (darkEdge - lightEdge)), 0.0, 1.0);

    // put a grid on the floor
    mat4 eyeOffset = getVisionSqueezeSensorSpaceEyeOffset(int(varTexCoord0.x > 0.5));
    TransformCamera cam = getTransformCamera();
    mat4 hmdSensorMatrix = getHMDSensorMatrix();
    vec4 ndc;
    if (varTexCoord0.x < 0.5) {
        ndc = vec4(varTexCoord0.x * 4.0 - 1.0, varTexCoord0.y * 2.0 - 1.0, -1.0, 1.0);
    } else {
        ndc = vec4(varTexCoord0.x * 4.0 - 3.0, varTexCoord0.y * 2.0 - 1.0, -1.0, 1.0);
    }
    vec4 fragmentEyeCoords = hmdSensorMatrix * (cam._projectionInverse * eyeOffset * ndc);
    vec4 near4 = hmdSensorMatrix * eyeOffset * vec4(0.0, 0.0, 0.0, 1.0);
    vec3 near = (near4 / near4.w).xyz;
    vec3 far = fragmentEyeCoords.xyz / fragmentEyeCoords.w;

    // intersect a line from near to far with the plane y = 0
    float t = -(near.y - getVisionSqueezeGroundPlaneY()) / (far.y - near.y);
    vec3 R = near + t * (far - near);
    // use (x, z) from that intersection to determine grid color for this fragment
    float c =
        checkerboard(R.xz, 1.0) * 0.3 +
        checkerboard(R.xz, 10.0) * 0.2 +
        checkerboard(R.xz, 100.0) * 0.1 +
        0.1;
    c = c * float(t > 0);
    float spotlight = min(1.0, 1.5 - getVisionSqueezeSpotlightSize() * length(R.xz));
    vec3 gridColor = vec3(c * spotlight);

    tonedColor = mix(tonedColor, gridColor, frac);
    outFragColor = vec4(tonedColor, 1.0);
}
